---
title: JS模块规范：AMD，CMD，CommonJS
date: 2018-03-19 00:31:30
tags: [js]
categories: [tool]
---

早在蛮荒时代，编程届都不认可js这门语言，一度认为就是脚本中的垃圾，只能用官方提供的api在浏览器中执行简单的没有复杂逻辑的代码。commonJS作为js非一份子表示不服，希望通过CommonJS提供规范，最终的目标是一个类似与JAVA的标准库，也可以提供各种CommonJS规范之上的各种API编写运行于不同宿主的应用程序。知道09年，nodeJS诞生，js服务端编程的落地标志着'js模块化编程'正式诞生。

## 原始'模块'

为什么加引号呢？因为原始的写法并不能成为模块，只能是看成'模块'的样子：

```
函数写法：

function module1 () {
	//doing
}
function module1 () {
	//doing
}

对象写法：

var module1 = {
	name: '',
	m1: function () {

	},
	m2: function () {

	}
}

立即执行函数：

var module1 = (function(){
	// doing
})();



处理一下的复杂立即执行函数:

var module1 = ( function (mod){

　　　　//...

　　　　return mod;

　　})(window.module1 || {});

```

以上方法都可以模拟模块化编程的思想写代码，但是都不是真正的模块化。

## CommonJS


CommonJS标准规定，一个单独的文件就是一个模块，模块内需要讲对外暴露的变量放到exports对象里，可以是任意的对象、函数、数组，在这个文件中，任何未放到exports对象里的都是私有的，作用域只在当前文件内。使用require方法加载模块，返回值就是exports对象。

eg:

```
say.js

module.exports = function(str){  //输出say函数
	str = str ? str : '调用say';
	console.log(str);
}

app.js

var say = require('./say.js');  //引入say模块，返回值是一个函数

say();

运行app.js： 

➜ nodetest node app.js
调用say

```

## AMD

CommonJS是同步的，意味着你想调用模块里的方法，必须先用require加载模块。这对服务器端的Nodejs来说不是问题，因为模块的JS文件都在本地硬盘上，CPU的读取时间非常快，同步不是问题。

但在客户端浏览器用CommonJS加载模块将取决于网速，如果采用同步，网络情绪不稳定时，页面可能卡住。因此针对客户端出现了AMD异步模块定义。

eg：

```
var math = require('math.js');

math.add(2, 3);
```
require是同步的，执行到加载math.js语句时，必须等待其加载完才能继续执行，如果加载时间很长，整个应用会等待，出现假死状态。

因此AMD主要是为浏览器解决异步加载问题而诞生的 。

AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步加载模块，模块的加载不影响后面代码的执行。所有依赖这个模块的语句都定义在一个回调函数中，等到模块加载完成后，这个回调函数才会运行。

eg:

```
require(math, function(math){
	math.add(2, 3);
})
```

## AMD之require.js

### 优点简介
加载多个js文件：

```
	<script src="1.js"></script>
　　<script src="2.js"></script>
　　<script src="3.js"></script>
　　<script src="4.js"></script>
　　<script src="5.js"></script>
　　<script src="6.js"></script>
```

缺点：1. 都是同步，假死会发生。2.互相依赖。可以使用async和defer关键字使得加载异步，但可能因此在加载过程中丢失加载的顺序。

require解决之后：

	（1）实现js文件的异步加载，避免网页失去响应；
	（2）管理模块之间的依赖性，便于代码的编写和维护。

### 使用

```
index.html:

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>这是个测试</title>
	</head>
	<body>
		
	</body>

	<script src="./static/require.js" data-main="config.js"></script>
	
</html>

config.js

require.config({
    //By default load any module IDs from scripts/app
    baseUrl: './static',
    //except, if the module ID starts with "lib"
    paths:{   
		"jquery": ["http://libs.baidu.com/jquery/2.0.3/jquery", "lib/jquery/jquery-1.9.1.min"]
    }
});

require(['./app'], function(){
	console.log('已经加载了app.js');
})


./static/app.js

console.log('引用app.js');

require(['say'], function(say){
	console.log('引用say');
	console.log(say);
	say.sayName();
})





./static/require.js

./static/say.js

define(['jquery'],function($){ 

    var myModule = {}; //推荐方式  
    var moduleName = "say";  
    var version = "1.0.0";  
      
    myModule.moduleName = moduleName;  
    myModule.version = version;  
	myModule.sayName = function(){
		alert('hello');
	}
    return myModule;  
      
      
});  


```

首先需要引入require文件，创建全局变量require命名空间下的三个全局函数：
```
	define– 该函数用户创建模块。每个模块拥有一个唯一的模块ID，它被用于RequireJS的运行时函数，define函数是一个全局函数，不需要使用requirejs命名空间.
	require– 该函数用于读取依赖。同样它是一个全局函数，不需要使用requirejs命名空间.
	config– 该函数用于配置RequireJS.
```



然后：requireJS会根据data-main属性搜寻该脚本文件，这个文件是所有模块的入口文件，并设置所有文件的根路径，以此文件为入口加载所有相关的模块。类似于webpack打包的思路。

使用配置函数：

```
require.config({
    baseUrl: 'scripts/app',
     paths: {
        lib: '../lib'
    }, 
    shim: {
        'backbone': {
            deps: ['underscore'],
            exports: 'Backbone'
        }
    }
});


baseUrl——用于加载模块的根路径。
paths——用于映射不存在根路径下面的模块路径。
shims——配置在脚本/模块外面并没有使用RequireJS的函数依赖并且初始化函数。假设underscore并没有使用  RequireJS定义，但是你还是想通过RequireJS来使用它，那么你就需要在配置中把它定义为一个shim。
deps——加载依赖关系数组

```
模块开发：

```
定义模块：

say.js

define(['jquery'],function($){ 

    var myModule = {}; //推荐方式  
    var moduleName = "say";  
    var version = "1.0.0";  
      
    myModule.moduleName = moduleName;  
    myModule.version = version;  
	myModule.sayName = function(){
		alert('hello');
	}
    return myModule;  
      
      
});  


```

模块使用：

```
app.js

require(['say'], function(say){
	console.log('引用say');
	console.log(say);
	say.sayName();
})
```

